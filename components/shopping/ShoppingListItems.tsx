"use client";

import { useState, useMemo, useEffect } from "react";
import { useForm } from "react-hook-form";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Checkbox } from "@/components/ui/checkbox";
import { Badge } from "@/components/ui/badge";
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { ShoppingCart, Plus, Trash2, ArrowUpDown, ArrowUp, ArrowDown, Pencil, Loader2, Save, X } from "lucide-react";
import { createClient } from "@/lib/supabase/client";

interface ShoppingListItemsProps {
  items: any[];
  shoppingListId: string;
  isAutoGenerated: boolean;
}

type SortField = 'name' | 'quantity' | 'unit' | 'price' | 'status';
type SortDirection = 'asc' | 'desc';

interface ProductBase {
  id: string;
  name: string;
  measurement_unit?: { id: string; abbreviation: string };
  type: 'base';
}

interface UserProduct {
  id: string;
  custom_name: string;
  measurement_unit?: { id: string; abbreviation: string };
  type: 'user';
}

type Product = ProductBase | UserProduct;

interface MeasurementUnit {
  id: string;
  name: string;
  abbreviation: string;
}

export function ShoppingListItems({ items, shoppingListId, isAutoGenerated }: ShoppingListItemsProps) {
  const [localItems, setLocalItems] = useState(items);
  const [sortField, setSortField] = useState<SortField>('name');
  const [sortDirection, setSortDirection] = useState<SortDirection>('asc');
  const supabase = createClient();

  // State for inline add/edit form
  const [showAddItemForm, setShowAddItemForm] = useState(false);
  const [editingItem, setEditingItem] = useState<any | null>(null);
  const [searchTerm, setSearchTerm] = useState("");
  const [selectedProduct, setSelectedProduct] = useState<Product | null>(null);
  const [isSaving, setIsSaving] = useState(false);
  const [formError, setFormError] = useState<string | null>(null);
  const [measurementUnits, setMeasurementUnits] = useState<MeasurementUnit[]>([]);
  const [selectedUnitId, setSelectedUnitId] = useState<string | undefined>(undefined);
  const [estimatedPriceInput, setEstimatedPriceInput] = useState<string>("");
  const [showSearchResultsDropdown, setShowSearchResultsDropdown] = useState(false);
  // Load all products once for local filtering (like in diets)
  const [allProductBases, setAllProductBases] = useState<any[]>([]);
  const [allUserProducts, setAllUserProducts] = useState<any[]>([]);

  const { register, handleSubmit, reset, setValue, formState: { errors } } = useForm();

  // Fetch measurement units and all products on component mount
  useEffect(() => {
    let isMounted = true;
    
    const fetchData = async () => {
      try {
        // Fetch units
        const { data: unitsData, error: unitsError } = await supabase.from("measurement_units").select("id, name, abbreviation");
        if (!isMounted) return;
        if (unitsError) {
          console.error("Error fetching measurement units:", unitsError);
          setFormError("Erro ao carregar unidades de medida.");
        } else {
          setMeasurementUnits(unitsData || []);
        }

        // Fetch all products once (like in diets)
        const { data: productBases, error: baseError } = await supabase
          .from("product_bases")
          .select(`id, name, measurement_unit:measurement_units(id, abbreviation)`);
        if (!isMounted) return;
        if (baseError) {
          console.error("Error fetching product bases:", baseError);
          setFormError("Erro ao carregar produtos base.");
        } else {
          setAllProductBases(productBases || []);
          console.log("Loaded product bases:", productBases?.length || 0);
        }

        const { data: userProducts, error: userError } = await supabase
          .from("user_products")
          .select(`id, custom_name, measurement_unit:measurement_units(id, abbreviation)`);
        if (!isMounted) return;
        if (userError) {
          console.error("Error fetching user products:", userError);
          setFormError("Erro ao carregar produtos do usuário.");
        } else {
          setAllUserProducts(userProducts || []);
          console.log("Loaded user products:", userProducts?.length || 0);
        }
      } catch (error) {
        if (!isMounted) return;
        console.error("Error in fetchData:", error);
        setFormError("Erro ao carregar dados.");
      }
    };
    
    fetchData();
    
    return () => {
      isMounted = false;
    };
  }, [supabase]); // Keep supabase in dependencies but use isMounted flag

  // Handle estimated price input formatting
  const formatPrice = (value: string | number | null | undefined): string => {
    if (value === null || value === undefined || value === "") return "";
    const num = typeof value === "string" ? parseFloat(value.replace(",", ".")) : value;
    if (isNaN(num)) return "";
    return num.toFixed(2).replace(".", ",");
  };

  const parsePrice = (value: string): number | null => {
    const num = parseFloat(value.replace(",", "."));
    return isNaN(num) ? null : num;
  };

  const handlePriceChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    const cleanedValue = value.replace(/[^0-9,]/g, '').replace(/,(\d*),/g, ',$1');
    setEstimatedPriceInput(cleanedValue);
  };

  // Reset form state
  const resetForm = () => {
    reset();
    setSearchTerm("");
    setSelectedProduct(null);
    setFormError(null);
    setIsSaving(false);
    setShowAddItemForm(false);
    setEditingItem(null);
    setSelectedUnitId(undefined);
    setEstimatedPriceInput("");
    setShowSearchResultsDropdown(false);
  };

  // Filter products locally (synchronous, like in diets) - no async calls that cause re-renders
  const filteredProducts = useMemo(() => {
    if (!searchTerm.trim()) return [];
    if (selectedProduct) return []; // Don't show results if product is already selected
    
    const term = searchTerm.toLowerCase();
    const baseResults = (allProductBases || [])
      .filter(pb => pb.name?.toLowerCase().includes(term))
      .map(pb => ({ ...pb, type: 'base' as 'base' }));
    
    const userResults = (allUserProducts || [])
      .filter(up => up.custom_name?.toLowerCase().includes(term))
      .map(up => ({ ...up, name: up.custom_name, type: 'user' as 'user' }));
    
    const results = [...baseResults, ...userResults].slice(0, 50);
    console.log("Filtered products:", {
      searchTerm,
      totalBases: allProductBases.length,
      totalUsers: allUserProducts.length,
      filteredCount: results.length
    });
    return results;
  }, [searchTerm, selectedProduct, allProductBases, allUserProducts]);

  const handleSelectProduct = (product: Product) => {
    setSelectedProduct(product);
    setSearchTerm(product.type === 'base' ? product.name : product.custom_name);
    setFormError(null);
    setValue("productSearch", product.type === 'base' ? product.name : product.custom_name, { shouldValidate: true });
    setSelectedUnitId(product.measurement_unit?.id);
    setShowSearchResultsDropdown(false); // Hide dropdown after selection
  };

  const handleSaveItem = async (data: any) => {
    setFormError(null);
    if (!selectedProduct && !editingItem) {
      setFormError("Por favor, selecione um produto.");
      return;
    }
    if (!data.quantity || Number(data.quantity) <= 0) {
      setFormError("Por favor, insira uma quantidade válida.");
      return;
    }
    if (!selectedUnitId) {
      setFormError("Por favor, selecione uma unidade de medida.");
      return;
    }

    setIsSaving(true);
    try {
      const itemData: any = {
        quantity: Number(data.quantity),
        is_purchased: data.is_purchased || false,
        estimated_price: parsePrice(estimatedPriceInput),
        notes: data.notes ? data.notes.trim() : null,
        measurement_unit_id: selectedUnitId,
      };

      let updatedItem: any;

      if (editingItem) {
        const { data: updatedData, error: updateError } = await supabase
          .from("shopping_list_items")
          .update(itemData)
          .eq("id", editingItem.id)
          .select(`
            *,
            product_base:product_bases(id, name),
            user_product:user_products(id, custom_name),
            measurement_unit:measurement_units(id, abbreviation)
          `)
          .single();

        if (updateError) throw updateError;
        updatedItem = updatedData;

        setLocalItems(prev =>
          prev.map(item =>
            item.id === updatedItem.id ? updatedItem : item
          )
        );
      } else {
        itemData.shopping_list_id = shoppingListId;
        if (selectedProduct?.type === 'base') {
          itemData.product_base_id = selectedProduct.id;
        } else if (selectedProduct?.type === 'user') {
          itemData.user_product_id = selectedProduct.id;
        }

        const { data: newItemData, error: insertError } = await supabase
          .from("shopping_list_items")
          .insert(itemData)
          .select(`
            *,
            product_base:product_bases(id, name),
            user_product:user_products(id, custom_name),
            measurement_unit:measurement_units(id, abbreviation)
          `)
          .single();

        if (insertError) throw insertError;
        updatedItem = newItemData;

        setLocalItems(prev => [...prev, updatedItem]);
      }
      resetForm();
    } catch (err: any) {
      console.error("Erro ao salvar item:", err);
      setFormError(err.message || "Ocorreu um erro ao salvar o item.");
    } finally {
      setIsSaving(false);
    }
  };


  const handleTogglePurchased = async (itemId: string, purchased: boolean) => {
    try {
      const { error } = await supabase
        .from("shopping_list_items")
        .update({ is_purchased: purchased })
        .eq("id", itemId);

      if (error) throw error;

      setLocalItems(prev =>
        prev.map(item =>
          item.id === itemId ? { ...item, is_purchased: purchased } : item
        )
      );
    } catch (error) {
      console.error("Erro ao atualizar item:", error);
      alert("Erro ao atualizar item da lista");
    }
  };

  const handleDeleteItem = async (itemId: string) => {
    if (!confirm("Tem certeza que deseja excluir este item da lista?")) {
      return;
    }

    try {
      const { error } = await supabase
        .from("shopping_list_items")
        .delete()
        .eq("id", itemId);

      if (error) throw error;

      setLocalItems(prev => prev.filter(item => item.id !== itemId));
    } catch (error) {
      console.error("Erro ao excluir item:", error);
      alert("Erro ao excluir item da lista");
    }
  };

  const handleEditItem = (item: any) => {
    resetForm(); // Reset any previous form state
    setShowAddItemForm(true);
    setEditingItem(item);
    
    // Pre-populate the form fields
    setSearchTerm(item.product_base?.name || item.user_product?.custom_name || "");
    setValue("productSearch", item.product_base?.name || item.user_product?.custom_name || "", { shouldValidate: true });
    setValue("quantity", item.quantity || 0);
    setEstimatedPriceInput(formatPrice(item.estimated_price));
    setValue("notes", item.notes || "");
    setSelectedUnitId(item.measurement_unit?.id);
    
    setSelectedProduct({
      id: item.product_base_id || item.user_product_id,
      name: item.product_base?.name || item.user_product?.custom_name,
      custom_name: item.user_product?.custom_name,
      type: item.product_base_id ? 'base' : 'user',
      measurement_unit: item.measurement_unit
    });
    setFormError(null);
    setShowSearchResultsDropdown(true); // Show dropdown on edit to allow immediate search if desired
  };

  const handleSort = (field: SortField) => {
    if (sortField === field) {
      setSortDirection(sortDirection === 'asc' ? 'desc' : 'asc');
    } else {
      setSortField(field);
      setSortDirection('asc');
    }
  };

  const getSortIcon = (field: SortField) => {
    if (sortField !== field) return <ArrowUpDown className="h-4 w-4" />;
    return sortDirection === 'asc' ?
      <ArrowUp className="h-4 w-4" /> :
      <ArrowDown className="h-4 w-4" />;
  };

  const sortedItems = useMemo(() => {
    return [...localItems].sort((a, b) => {
      let aValue: any, bValue: any;

      switch (sortField) {
        case 'name':
          aValue = (a.product_base?.name || a.user_product?.custom_name || '').toLowerCase();
          bValue = (b.product_base?.name || b.user_product?.custom_name || '').toLowerCase();
          break;
        case 'quantity':
          aValue = Number(a.quantity || 0);
          bValue = Number(b.quantity || 0);
          break;
        case 'unit':
          aValue = (a.measurement_unit?.abbreviation || '').toLowerCase();
          bValue = (b.measurement_unit?.abbreviation || '').toLowerCase();
          break;
        case 'price':
          aValue = Number(a.estimated_price || 0);
          bValue = Number(b.estimated_price || 0);
          break;
        case 'status':
          aValue = a.is_purchased ? 1 : 0;
          bValue = b.is_purchased ? 1 : 0;
          break;
        default:
          return 0;
      }

      if (aValue < bValue) return sortDirection === 'asc' ? -1 : 1;
      if (aValue > bValue) return sortDirection === 'asc' ? 1 : -1;
      return 0;
    });
  }, [localItems, sortField, sortDirection]);

  const purchasedItems = localItems.filter(item => item.is_purchased).length;

  return (
    <Card>
      <CardHeader>
        <div className="flex items-center justify-between">
          <div>
            <CardTitle>Itens da Lista</CardTitle>
            <CardDescription>
              Gerencie os itens da sua lista de compras
            </CardDescription>
          </div>
          <Button onClick={() => { resetForm(); setEditingItem(null); setShowAddItemForm(true); }}>
            <Plus className="mr-2 h-4 w-4" />
            Adicionar Item
          </Button>
        </div>
      </CardHeader>
      <CardContent>
        {formError && (
          <div className="mb-4 text-red-600 text-sm">
            {formError}
          </div>
        )}
        {localItems && localItems.length > 0 || showAddItemForm ? (
          <div className="space-y-4">
            {/* Resumo */}
            <div className="flex items-center justify-between text-sm">
              <span>
                Total: <strong>{localItems.length}</strong> itens
              </span>
              <div className="flex gap-4">
                <span className="text-green-600">
                  ✅ Comprados: <strong>{purchasedItems}</strong>
                </span>
                <span className="text-orange-600">
                  ⏳ Pendentes: <strong>{localItems.length - purchasedItems}</strong>
                </span>
              </div>
            </div>

            {/* Tabela */}
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead className="w-12"></TableHead>
                  <TableHead>
                    <Button
                      variant="ghost"
                      size="sm"
                      className="h-auto p-0 font-medium"
                      onClick={() => handleSort('name')}
                    >
                      Produto
                      {getSortIcon('name')}
                    </Button>
                  </TableHead>
                  <TableHead className="text-center">
                    <Button
                      variant="ghost"
                      size="sm"
                      className="h-auto p-0 font-medium"
                      onClick={() => handleSort('quantity')}
                    >
                      Quantidade
                      {getSortIcon('quantity')}
                    </Button>
                  </TableHead>
                  <TableHead className="text-center">
                    <Button
                      variant="ghost"
                      size="sm"
                      className="h-auto p-0 font-medium"
                      onClick={() => handleSort('unit')}
                    >
                      Unidade
                      {getSortIcon('unit')}
                    </Button>
                  </TableHead>
                  <TableHead className="text-center">
                    <Button
                      variant="ghost"
                      size="sm"
                      className="h-auto p-0 font-medium"
                      onClick={() => handleSort('price')}
                    >
                      Preço Estimado
                      {getSortIcon('price')}
                    </Button>
                  </TableHead>
                  <TableHead className="text-center">
                    <Button
                      variant="ghost"
                      size="sm"
                      className="h-auto p-0 font-medium"
                      onClick={() => handleSort('status')}
                    >
                      Status
                      {getSortIcon('status')}
                    </Button>
                  </TableHead>
                  <TableHead className="w-24 text-right">Ações</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {(showAddItemForm || editingItem) && (
                  <TableRow className="bg-muted/50">
                    <TableCell colSpan={2}>
                      <div className="relative w-full">
                        <Input
                          {...register("productSearch", { required: !editingItem && !selectedProduct })}
                          type="text"
                          placeholder="Buscar produto..."
                          value={searchTerm}
                          onChange={(e) => {
                            const value = e.target.value;
                            setSearchTerm(value);
                            setSelectedProduct(null); // Clear selected product on new search input
                            // Always show dropdown when typing
                            setShowSearchResultsDropdown(true);
                          }}
                          onFocus={() => {
                            setShowSearchResultsDropdown(true);
                          }}
                          onBlur={() => setTimeout(() => setShowSearchResultsDropdown(false), 200)}
                          className="pr-10 w-full"
                          disabled={isSaving}
                        />
                        {searchTerm.trim() && !selectedProduct && showSearchResultsDropdown && (
                          <div className="absolute z-50 bg-background border rounded-md shadow-lg w-full max-h-48 overflow-y-auto mt-1 top-full left-0">
                            {filteredProducts.length > 0 ? (
                              filteredProducts.map((product) => (
                                <div
                                  key={product.id}
                                  className="px-4 py-2 cursor-pointer hover:bg-accent hover:text-accent-foreground"
                                  onMouseDown={(e) => e.preventDefault()} // Prevent blur before click
                                  onClick={() => handleSelectProduct(product)}
                                >
                                  {product.type === 'base' ? product.name : product.custom_name}
                                  {product.measurement_unit && ` (${product.measurement_unit.abbreviation})`}
                                </div>
                              ))
                            ) : (
                              <div className="px-4 py-2 text-sm text-muted-foreground">
                                {allProductBases.length === 0 && allUserProducts.length === 0 
                                  ? "Carregando produtos..." 
                                  : "Nenhum produto encontrado"}
                              </div>
                            )}
                          </div>
                        )}
                      </div>
                      {errors.productSearch && <span className="text-red-500 text-xs">Selecione um produto</span>}
                    </TableCell>
                    <TableCell className="text-center">
                      <Input
                        {...register("quantity", { required: true, min: 0.01 })}
                        type="number"
                        step="0.01"
                        disabled={isSaving}
                        className="text-center"
                      />
                      {errors.quantity && <span className="text-red-500 text-xs">Obrigatório</span>}
                    </TableCell>
                    <TableCell className="text-center">
                      <Select
                        value={selectedUnitId}
                        onValueChange={(value) => setSelectedUnitId(value)}
                        disabled={isSaving}
                      >
                        <SelectTrigger className="w-full">
                          <SelectValue placeholder="Selecione" />
                        </SelectTrigger>
                        <SelectContent>
                          {measurementUnits.map((unit) => (
                            <SelectItem key={unit.id} value={unit.id}>
                              {unit.abbreviation}
                            </SelectItem>
                          ))}
                        </SelectContent>
                      </Select>
                      {errors.measurement_unit_id && <span className="text-red-500 text-xs">Obrigatório</span>}
                    </TableCell>
                    <TableCell className="text-center">
                      <Input
                        {...register("estimated_price")}
                        type="text"
                        value={estimatedPriceInput}
                        onChange={handlePriceChange}
                        disabled={isSaving}
                        className="text-center"
                      />
                    </TableCell>
                    <TableCell>
                      <Input
                        {...register("notes")}
                        type="text"
                        disabled={isSaving}
                        className="text-center"
                      />
                    </TableCell>
                    <TableCell className="text-right">
                      <div className="flex gap-2 justify-end">
                        <Button
                          variant="ghost"
                          size="sm"
                          onClick={handleSubmit(handleSaveItem)}
                          disabled={isSaving || (!selectedProduct && !editingItem && !selectedUnitId)}
                        >
                          {isSaving ? <Loader2 className="h-4 w-4 animate-spin" /> : <Save className="h-4 w-4" />}
                        </Button>
                        <Button
                          variant="ghost"
                          size="sm"
                          onClick={resetForm}
                          disabled={isSaving}
                        >
                          <X className="h-4 w-4" />
                        </Button>
                      </div>
                    </TableCell>
                  </TableRow>
                )}

                {sortedItems.map((item: any) => {
                  const productName = item.product_base?.name ||
                                    item.user_product?.custom_name ||
                                    "Produto";

                  return (
                    <TableRow key={item.id} className={item.is_purchased ? "opacity-60" : ""}>
                      <TableCell>
                        <Checkbox
                          checked={item.is_purchased}
                          onCheckedChange={(checked) =>
                            handleTogglePurchased(item.id, checked as boolean)
                          }
                        />
                      </TableCell>
                      <TableCell className="font-medium">
                        <span className={item.is_purchased ? "line-through text-muted-foreground" : ""}>
                          {productName}
                        </span>
                      </TableCell>
                      <TableCell className="text-center">
                        {item.quantity}
                      </TableCell>
                      <TableCell className="text-center">
                        {item.measurement_unit?.abbreviation || "un"}
                      </TableCell>
                      <TableCell className="text-center">
                        {item.estimated_price ?
                          `R$ ${formatPrice(item.estimated_price)}` :
                          "-"
                        }
                      </TableCell>
                      <TableCell className="text-center">
                        <Badge
                          variant={item.is_purchased ? "default" : "secondary"}
                          className={item.is_purchased ? "bg-green-100 text-green-800" : ""}
                        >
                          {item.is_purchased ? "Comprado" : "Pendente"}
                        </Badge>
                      </TableCell>
                      <TableCell className="text-right">
                        <div className="flex gap-2 justify-end">
                          <Button
                            variant="ghost"
                            size="sm"
                            onClick={() => handleEditItem(item)}
                            disabled={isSaving}
                          >
                            <Pencil className="h-4 w-4" />
                          </Button>
                          <Button
                            variant="ghost"
                            size="sm"
                            onClick={() => handleDeleteItem(item.id)}
                            className="text-destructive hover:text-destructive"
                            disabled={isSaving}
                          >
                            <Trash2 className="h-4 w-4" />
                          </Button>
                        </div>
                      </TableCell>
                    </TableRow>
                  );
                })}
              </TableBody>
            </Table>
          </div>
        ) : (
          <div className="text-center py-8">
            <ShoppingCart className="mx-auto h-12 w-12 text-muted-foreground" />
            <h3 className="mt-2 text-sm font-semibold">
              {isAutoGenerated ? "Lista não pôde ser gerada automaticamente" : "Nenhum item na lista"}
            </h3>
            <div className="mt-1 text-sm text-muted-foreground">
              {isAutoGenerated ? (
                <div className="space-y-2">
                  <p>Esta lista foi gerada automaticamente, mas não encontrou itens para adicionar.</p>
                  <p className="text-xs">
                    Possíveis motivos:
                  </p>
                  <ul className="text-xs list-disc list-inside space-y-1">
                    <li>Sua dieta pode não ter refeições configuradas</li>
                    <li>Os produtos da dieta podem já estar no estoque</li>
                    <li>Não há produtos específicos da dieta para comprar</li>
                  </ul>
                </div>
              ) : (
                <p>Adicione itens à sua lista de compras.</p>
              )}
            </div>
            <div className="mt-6">
              <Button onClick={() => { resetForm(); setEditingItem(null); setShowAddItemForm(true); }}>
                <Plus className="mr-2 h-4 w-4" />
                {isAutoGenerated ? "Adicionar Itens Manualmente" : "Adicionar Primeiro Item"}
              </Button>
            </div>
          </div>
        )}
      </CardContent>
    </Card>
  );
}
